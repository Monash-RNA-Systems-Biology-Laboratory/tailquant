---
title: "Usage with the older Tail Tools package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage alongside Tail Tools}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

[Tail Tools](https://github.com/Monash-RNA-Systems-Biology-Laboratory/tail-tools) is our lab's older package for processing PAT-Seq sequencing data. This article describes hybrid usage of tailquant and Tail Tools.


## Usage after Tail Tools with older PAT-Seq data

Older PAT-Seq data was received as single-ended reads in demultiplexed form, which would then be fed directly to the Tail Tools pipeline.

tailquant could then be used to ingest the output of the Tail Tools pipeline:

```r
library(tailquant)

# Enable multiprocessing (optional, fragile).
future::plan(future::multicore, workers=8)

# Process an existing Tail Tools pipeline.
# Creates a new directory called my_output_dir
ingest_tt(
     out_dir="my_output_dir"
    ,in_dir="my_tail_tools_pipeline_dir"
    ,tail_source="tt"  # Where to get tail lengths from. "tt" means from Tail Tools output.
    ,site_pad=10       # (default) Reads alignments ending +/-10 bases of a site are examined.
    ,min_tail=13       # (default) Minimum "A"s to consider as having a poly(A) tail.
    ,length_trim=10    # (default) poly(A) tail reaching within 10 bases of the end 
                       #           we treat as not having ended.
    )
```

You can then use the resulting directory with the Shiny app, as described in the "Usage" article.


## Demultiplexing and poly(T) length calling for newer PAT-Seq data

tailquant can be used to demultiplex reads before using Tail Tools. It can then make use of poly(T) length information from read 2 if this is available.

See the "Usage" article for how to run `ingest_read_pairs()`. Then you can use the following to create fastq files for Tail Tools:

```r
library(tailquant)

# Enable multiprocessing (optional, fragile).
future::plan(future::multicore, workers=8)

demux_reads(
     out_dir="my_output_dir" 
    ,in_dir="reads"
    ,max_t_read_1=20   # (default) Discard any reads with a run of Ts longer than this in read 1
    #,min_t=13         # Optionally discard any read pairs without poly(T) in read 2 
    )
```

* We've observed in read 1 there are often reads with long spans of "T"s. These are filtered by default by `demux_reads`. We would also always expect to see a poly(T) in read 2 corresponding the the poly(A) tail. `demux_reads` can also optionally filter reads that lack this.

`demux_reads` produces fastq files suitable for Tail Tools. Tail Tools should be run with the clipping setting `adaptor="rc_umi_rc_barcode"`.

The poly(T) lengths can then be used when ingesting Tail Tools output:

```r
# Process an existing Tail Tools pipeline, but use poly(T) lengths.
# Creates a new directory called my_output_dir
ingest_tt(
     out_dir="my_output_dir"
    ,in_dir="my_tail_tools_pipeline_dir"
    ,tail_source="read2"    # Where to get tail lengths from.
    ,read_pairs_dir="reads"
    ,min_tail=13            # (default) Minimum "T"s to consider as having a poly(A) tail.
    ,length_trim=0          # poly(T) should be fine reaching to the end of read2.
    )
```

You can then use the resulting directory with the Shiny app, as described in the "Usage" article.


## Using tests with the old Tail Tools differential test Shiny app

Tests for tailquant can be converted to work with the older Tail Tools software using the function `tests_to_tt()`.

See the "Usage" vignette for how to create tailquant test specifications.

```r
library(tailquant)
library(tailtools)

# ... create a variable called tests with the test specifications ...

tt_app <- shiny_tests( 
    tests_to_tt(tests, pipeline_dir="my_tail_tools_pipeline_dir"),
    title="Tail Tools differential tests")

tt_app
```

