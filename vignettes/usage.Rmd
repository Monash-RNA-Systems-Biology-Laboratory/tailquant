---
title: "Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Getting started

```r
library(tailquant)

# Enable multiprocessing.
# - Optional! Fragile!
# - Do not use from within RStudio, except by invoking R in the terminal.
# - future::multisession may also work, if multicore isn't available, or it may also fail.
future::plan(future::multicore, workers=6)
```

## Make a reference directory

```r
make_reference(
     out_dir="my_reference_dir"     # This directory will be created
    ,genome="genome.fasta"          # FASTA reference sequence
    ,annotation="annotation.gff3")  # gff3 gene annotation
```

## Ingest reads

We expect read pairs with:

* In read 1, sequence transcribed from the genome, possibly followed by a poly(A) tail sequence, and then possibly followed by UMI and barcode sequence.
* In read 2, a barcode, a UMI, and poly(T) sequence in read 2.

Due to the primers used, the poly(T) sequence is expected to be of length at least 12. Seeing a poly(T) of 13 bases or more in read 2 indicates we are seeing real poly(A) tail and not just primer sequence.

We also sometimes observe read pairs where there is a long span of "T"s in read 1. We think these are not real, and should be filtered. 

```r
# ... 
# Create a data frame of samples with columns:
#     sample  - a sample name
#     barcode - barcode sequence (as seen in read 2)
# ...

# Have a look at your FASTQ file to check an appropriate quality cutoff.
# Ends of reads will be clipped at the point 1 in 5 non-G bases start falling below this quality.

# Step 1 loads all of the read pairs into a parquet file, 
# and calls samples, quality clipping, poly(A), and poly(T) lengths.
ingest_read_pairs(
     out_prefix="reads"   # <- A directory called reads will be created
    ,reads1="reads1.fastq.gz"
    ,reads2="reads2.fastq.gz"
    ,clip_quality_char="I" # <- Check this is appropriate
    ,samples=samples
    )

```

You can now examine `reads.peek.txt` and `reads.report.html` to assess quality. `reads.peek.txt` shows a random selection of reads, and tailquant's interpretation of where the poly(A) and poly(T) tails are. `reads.report.html` is an HTML report giving a summary of tail identification, sample assignment, and UMI usage.

The parquet files in `my_output_dir` contain the input reads, sample assignment, UMIs, and information about poly(A) and poly(T) lengths. These are big files, so be sure to delete them once you are done with them.


## Run pipeline


## Shiny app

```r
# Allow shiny app to use background workers. Optional, fragile.
future::plan(future::multicore, workers=8)

# Open Shiny app
tq <- load_tq("my_output_dir")
app <- tq_shiny(tq, title="Tail length examiner for this dataset")
app
```

The tailquant Shiny app supports a wide range of linear model based differential tests. 

Tests are specified in a named list:

* The name of each item will be used in a cache filenames.
* Each item is itself a named list containing:
    * "design" - matrix with row names corresponding to sample names - a design matrix as in limma etc.
    * "contrasts" - matrix with column names - a contrast matrix as in limma etc. Should have as many rows as there are columns in the design matrix. A single column specifies a t-test, and multiple columns specifies an F-test.
    * "title" - string - a title for the test.

For common experimental designs tailquant provides helper functions `make_tests_oneway` and `make_tests_twoway`.

For example, suppose your sample names were named like `group_replicate`, you could use:

```r
library(tidyverse)

# Use a regular expression to extract parts from the sample names
# and convert them to factors.
sample_names <- tq@samples$sample
parts <- str_match(sample_names, "(.*)_(.*)")
group <- fct_inorder(parts[,2])
rep <- fct_inorder(parts[,3])

# Construct tests for an experiment with one experimental factor.
# The batches argument is optional, only include it if you believe there is a batch effect.
tests <- make_tests_oneway(sample_names, groups=group, batches=rep)

app <- tq_shiny(tq, tests=tests, title="App with differential tests")
app
```
